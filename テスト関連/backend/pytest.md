# pytest周りの整理

## 理解
- @pytest.fixtureを使用することで、テストの前処理を記述できる。
    - 複数の引数を渡したい場合は、params=[]に記述する。
        - paramsに複数の値を渡すと、その値毎にテストケースが実行される。<br>
        ⇒つまり、最初に事前データを一括で作成しておいて、各ケースで違うデータを使用したい場合には有効活用できない。<br>
        ⇒その場合にはparamsではなく、fixture関数の中にリスト形式等で記載する。
    - fixtureにはスコープが存在する。

        | スコープ名 | 粒度 |
        | ---- | ---- |
        | function | テストケース |
        | class  | テストクラス |
        | module  | テストファイル |
        | class  | テスト全体 |

- ユーザなど複数のテストから呼び出す処理は「conftest.py」に記述をする。
    <br>※「conftest.py」は同階層と親階層を利用できる。

- @pytest.mark.parametrizeを使用すると、同じテストを複数のパラメータで簡単に行える。

- mocker.patchを使用することで、メソッドや外部API接続をmock化できる。

- プロジェクト内に複数のappが存在する場合、デフォルトでtest.pyがappごとに配置される。<br>とすると、testsフォルダもapp毎に作成していくのが良さそう。

- loaddataで入れているマスタデータはcall_command()を利用することで、テストDBに入れることも可能。<br>但し、フォルダ配下のファイルを*で指定はできずファイル名を指定する必要あり。

- 

## 疑問
- mock, patch周りの違いは？
- 実装した関数だけでなく、datetime.now()などの標準モジュール等の置き換えは可能？
- 事前データとして複数テーブルを作成する場合、同じfixtureとしてまとめるか、それぞれ分けるか？
- fixturesにてbulk_createでデータを作った時、その元となったリストをテストケースで使い回せるか？また、それは一般的か？