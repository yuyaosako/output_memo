# 例外処理関連の整理

## 理解
- 例外とは、「通常動作と異なる挙動で、予め想定できるもの」を指す。
- 例外処理を行わないと、処理を続けたいのに続けられない。続けたくないのに続けられてしまう。などの事象が発生する。
- エラー時の方針
    1. エラーが発生した時点ですぐに中断する
    2. リソースを開放する
    3. エラー情報をログに残す
- 「全ての例外ハンドラーを除去してもプログラムが動作するか？」<br>⇒「ノーの場合、例外ではない状況下で例外が発生している。」
- 例外は以下のように分類できる。
    1. システム例外<br>DB接続の失敗、API連携の失敗、データ不整合、など。<Br>ユーザでは対応不可なレベル。<br>基本的にはフレームワークレベルでハンドリングされる。
    2. アプリケーション例外（回復不可）<br>商品の在庫切れ、残高不足など。<br>ビジネスルール違反としてユーザに通知するレベル。
    3. アプリケーションリカバリ例外（回復可）<br>タイムアウトなど。<br>再操作でリカバリ可能としてユーザに通知するレベル。
    4. プログラム違反例外<Br>Nullポなど。<br>プログラム開発者へ通知するエラー。
- Djangoでは、基本的にフレームワーク側が例外処理を行ってくれるため、無理にハンドリングする必要はない。<br>但し、ロギングに関してはsettins.pyに記載が必要。
- pythonで例外処理に使う記述は以下の通り。
    - else : 正常終了時の処理
    - finally : 終了時に常に行う処理
    - pass : 例外を無視する
    - ※try-exceptの記述だと、例外発生時はexcept内の処理を行い、そのまま後述処理も実行される。

- エラー発生時、print(e)を使わずlogging.●●()を使用することで、環境ごとの差異にも対応できる。

- 参考記事
    - https://qiita.com/TairaNozawa/items/8788c4b20c60046ee80c
    - https://qiita.com/TairaNozawa/items/ab878eaa0b9f64b9854f

- メソッドを分割している場合、親メソッドにもハンドリングを伝播させたい場合は親メソッドでもtry句を作成する。
    - 案件では子メソッドでエラー時はmessageとstatusをreturnしていたので、親メソッドではifによる条件分岐のみとした。
## 疑問
- 個別でtry-exceptを行うと、記述者によって差異が生まれるため一括で管理する方が良い？