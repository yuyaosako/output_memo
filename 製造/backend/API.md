# API関連の整理

## 理解

- モバイルアプリやwebサイトなど、1つの実装で複数のコンシューマから利用することが可能。

- APIは組み合わせて色々と使えるからこそ、新規参画者や外部公開した時に使用しやすいような設計をすることが必要。

- APIは何ができるのかが分かればよく、その中身に関しては利用者には関係ない。

- API設計する際、コンシューマ(利用するユーザとソフトウェア)の視点に焦点を合わせることが礎となる。

- API設計時に考慮するポイント
    - 誰が使えるのか？
    - 何ができるのか？
    - それをどのように行うのか？
    - そのために何が必要か？
    - 何が返されるのか？

- APIの内容がデータ構造とほぼイコールになっていたらプロバイダ視点に立っている可能性が高いので再考が必要。

- プロバイダ視点での設計出の弊害は、コンシューマとは無関係な部分をAPIが曝け出すことに関連している。

- REST APIではメインリソースに結び付く動詞に注目する。<br>商品をカタログに追加する。の場合、カタログの追加アクションで、商品はパラメータ。

- 同じリソースを返すAPIだとしても、戻り値として必要最低限のデータのみ渡すため、その中身のデータまでが必ず一緒とは限らない。
    - 但し、原則的に同じ変数として期待することが大半のため、特別な理由がない限りは同一の変数名を使用する。

- 実装をRESTに準拠させるのが難しい場合は、アクションリソースを使用したりする選択肢もあるが、いずれもコンシューマ視点を忘れない。

- RESTfulに保つためには以下の6点に注意すべき。
    1. クライアントとサーバーの分離
    2. ステートレス性
        - requestの実行に必要な全ての情報がrequest自体に含まれてなければならない。
    3. キャッシュ可能性
    4. 階層化システム
        - クライアントからは1つの層が見えるのみとする。（裏にあるストラクチャは気にしない）
    5. コードオンデマンド
    6. 統一インターフェース
        - 全てのやり取りを識別されたリソースに従って行う。(一意なパスと標準化されたHTTPメソッドを使用など) 
        - メタデータも全て提供する。

- DBの値をそのまま返すのではなく、使用しやすいようにデータ型やデータフォーマットには気を遣うべき。
    - DBでは1, 2, 3等の数値コードを使っていたとしても、responseには"code1の値","code2の値"などの文字列にするとか。
        - 数値コードがなんらかの理由で必要な場合は両方返すなども良い。
    - 12345という数値なども桁数が決まっていれば"00012345"にするとか。
    - APIドキュメントを見れば型も分かるため、長くなるならパラメターなどに型を示す文言はなくても良い。
        - 寧ろユーザフレンドリにし、ユーザが分かりやすい変数名を使用するべき。

- 1つのrequestで複数のエラーが発生している場合は包括的なフィードバックを1度で返すべき。

- エラーを予め分析し、回避する方法を実装しておくことも必要。
    - エラー回避できるような付加価値を持つデータを突き止める。
    - 上記を提供する新しいゴールを作成する。（responseに含むのかAPIを作成するのか）

- 一貫性を図ることが大事。一貫性のレベルとしては以下などがある。
    1. API内部での一貫性
    2. 組織内のAPIにまたがる一貫性
    3. APIの問題領域での一貫性
    4. 外界・世間一般との一貫性

- コンテントネゴシエーション」単一のリソースを様々な表現で交換できるようにするHTTPメカニズム。
    - requestの場合はContent-Typeに、responseの場合はAccept:に指定するメディアタイプを記述する。(フロント側)
        - ほとんどの場合はapplication/json

- 使いやすいAPIを提供するには、データグループを作成すると良い。
    - 関連するプロパティを近くにまとめる
    - 共通のプレフィックスを使う
    - 部分構造を定義するなど
    - 重要な項目から上に並べる
など

- APIの粒度を正しく選択するということは、1つのゴールで2つの異なることを行わないようにするということ。
    - ゴールの細かさは常に一定ではない。

- 最小権限の原則
    - APIはwebに公開する場合がほとんどなので、セキュリティの関連から考えると空いているドアが少なければ少ないほど良い。
    - そのためにアクセス制御、スコープ設計を厳密に行う必要がある。

- スコープ設計には、柔軟だが複雑な細分化戦略とよりユーザフレンドリな大まかな戦略があり、状況に応じて選択していく必要がある。

- センシティブデータの扱いには注意が必要
    1. センシティブデータの特定
    2. データ表現の考案
        - センシティブデータを削除する
        - センシティブな値を置換する
        - センシティブな値を暗号化する　など
    3. API制御
        - 非センシティブデータを返すAPIのデータを用いてセンシティブデータ取得APIを叩く
        - スコープによって返すデータの切り分け
        - アクセストークン等に紐づけられたパーミッション、ロール等による切り分け
        - スコープ、パーミッションの組み合わせによる切り分け　など

- APIの使用が開始されている場合、プロパティの名称変更・移動・削除・型変更などは破壊的変更になり完全に修正することは難しい。
    - 理想から遠くても現状の形を崩さず本来やるべきこと（機能追加など）を行う道を探る場面も往々にしてある。
    - 逆に、入出力データ等を変更する場合は影響調査をしっかりやらないとバグに繋がる。
    - 現状はbackend、frontendが分かれてなくAPI公開もしていないため、自身らが把握していれば良いので修正は楽だが、状況が変わればそうもいかなくなる。

- 外部公開している場合は気軽に変更できず、バージョンアップという形で変更する必要がある。(1.0 ⇒ 1.1とか)
- APIのバージョンは実装がどのように進化するかではなく、インターフェイスコントラクトに対する変更に基づいて進化する。

- セマンティックバージョニング：<メジャー>.<マイナー>.<パッチ>の数字で構成される。
    - メジャー：破壊的変更(新しい必須パラメータの追加など)が及ぼされた時に限って数字をあげる。
    - マイナー：後方互換性のある方法(HTTPメソッドやリソースパスの追加など)によって新機能を追加する時に数字をあげる。
    - パッチ　：後方互換性のあるバグフィックス関連の変更を追加する時に数字をあげる。

- APIに適用させる場合は上記の内、<破壊的>.<非破壊的>の2つのみであり、更にコンシューマからすると<破壊的>のみ必要。
    - つまり、APIのバージョニングと実装のバージョニングは必ずしも一致しない。

- 設計時には、拡張性を意識した実装が必要。
    - 拡張性は、文字列 > 数値 > boolの順で高い。
    - 複数のプロパティが追加されそうな場合は、リスト型のオブジェクトにまとめられないか検討することで破壊的変更を抑えられる。
    - 破壊的変更のリスクを抑えた上で変更を行えるようにするだけでなく、とうしょの目的だけでない幅広いユースケs－スで利用できるようにすることも含まれている。
    - 設計しているフローを特定のプロセスに関連付けずｍ各ステップをスタンドアロンで利用できるようにする。
- そのためには、より小さなAPIを構築していくことが必要。

- ネットワークの通信効率は「速度」、「データ量」、「呼び出し数」の3要因に分けられることが多く、設計時に意識すべき。

## 疑問
- APIの粒度は？
- コードオンデマンドとは？
- 外部公開しない場合にAPIを利用するメリットは？