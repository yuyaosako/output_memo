# コンテナ・Docker周りの整理

## 【コンテナの基礎】
- 従来の課題
    - OSやライブラリ、FW、他アプリケーションやDBなどが環境ごとによって異なる。
        - この環境差異が原因で他の環境では動くが、本番では動かない等の事象が発生することが課題だった。
- コンテナの利点
    - コンテナ技術により、アプリケーションの実行基盤はコンテナを動かせばよいだけとなり、環境差異が生まれなくなった。
    - コンテナイメージ：OS + アプリケーション環境を1つのパッケージイメージとしてまとめたもの。
    - コンテナ：コンテナイメージを展開したもの。

- コンテナアプリケーション開発のライフサイクル
    1. Build：OSとアプリケーション環境を1つのコンテナイメージにすること。
        - Dockerfileを記述し、イメージを作成する工程。
        - 従来であれば実行環境がコンパイルして実行ファイルを作成する工程。
    2. Ship：コンテナイメージを移動、共有すること。
        - Push：完成したコンテナイメージをイメージレジストリ(Docker Hubなど)に格納する。
        - Pull：コンテナプラットフォームから取り込む。
    3. Run：コンテナイメージを展開して稼働させること。

- ## 【Docker】
- コマンド(頻繁に利用するもののみ)
    - `docker image build`
        - Dockerfileに記述した内容を上から順番に処理していく。
        - リポジトリ名を付けないとpushできない。
            -t コンテナイメージ名 Dockerfileパス
    - `docker container ls オプション`
        - build or pullしたコンテナイメージの確認
        - -a : Exitedも含めたすべてのイメージを確認できる
    - `docker container run`
        - イメージを元にコンテナを起動する。
        - Dockerfileで定義されたCMDやENTRYPOINT命令でアプリケーションが実行されている状態。
        - --name : 起動するコンテナに名前を付ける
        - -d : バックグラウンドで起動する
        - -p : ポート指定(ホストポート : コンテナポート)
    - `docker container exec -it コンテナ名 or ID`
        - 稼働しているコンテナに接続する。
        - -it : 標準出力を開いたままにできるため、対話的な入力が可能。デフォルトで設定してよい。
    - `docker container stop`
        - 稼働しているコンテナを停止する
    - `docker container start`
        - 停止したコンテナを再稼働する。
        - runは新規起動、startは再起動の違いがある。
    - `docker container cp コンテナホストのコピー元パス コンテナ名orID：コンテナ内のコピー先パス`
        - 稼働中にコンテナでホストとファイルのやり取りをする。
        - コンテナ同士の場合は別コマンドを利用する。
    - `docker container rm`
        - コンテナを停止して削除する

- コンテナイメージの軽量化
    - DockerfileのFrom命令のみで参照可能なscratchなどの軽量なベースイメージの利用
    - コマンドの連結(1行ずつ実行されるため、実行行は少ない方が良い。)
        - RUN ○○ && ●●　など
        - ※最初は1行ずつ書いてトライ＆エラーをした後、まとめる。

- Dockerfileに記述する書式
    - COPY：localにあるファイルやディレクトリを配置する場合に使用。
    　- COPY <配置元>・・・ <配置先>
    - ADD：リモートファイルやtarファイルを配置する場合に使用。

## 課題
- 仮想マシンとの違いは？
- ハイパーバイザーとは？
- カーネルとは？
- マルチステージビルドについて
- CI/CDについて
- VscodeのdevContainerについて